#!/usr/bin/env groovy

import java.util.jar.JarFile;
import groovy.sql.Sql
import groovy.json.JsonSlurper;

// Parse the xml file, and does two things:
// 1. Generates two files - one that contains stats for each jar and the other that ties each of these 
//                          jars to specific components.
// 2. Bulk loads this into a database for analysis.
public class ParseTextFile {

  public static void main(String[] args) {
    // This file is expected to be present, and is generated by the script
    // thirdparty_jar_harmonization.sh.
    def out = new XmlParser().parse("./xml_formatted_output.xml");
    File f = new File("./jar_stats.txt");
    File f1 = new File("./jar_component_map.txt");

    // Make sure that both these files exist.
    if ( !f.exists() || !f1.exists()) {
        throw new FileNotFoundException("One of jar_stats.txt or jar_component_map.txt does not exist");
    }

    PrintWriter statsWriter = new PrintWriter(f)
    PrintWriter jarComponentWriter = new PrintWriter(f1)
    def date= out.date.text()
    def separator="+++"

    try {
        // Parse the XML and do formatting so that the resulting output file.
        // can be fed as bulk.
        out.jarFile.each {
          def jarName= it.'jarFileName'.text()
          def jarCount= it.'jarFileCount'.text()
          def jarNameSearchPattern=it.'jarFileSearchPattern'.text()
          def jarVersions= it.'jarFileWithVersions'.text().trim().replaceAll("\n", ",")
          def jarComponentMap= it.'jarFileSymlinks'.text().trim().replaceAll("\n", ",")
          def componentNameJarMap = [:]
          jarComponentMap.split(",").each  {
            def local_splitString=it.split("->");
            def local_compoenentName=local_splitString[0]
            def local_jarName=local_splitString[1]
            if(componentNameJarMap.containsKey(local_compoenentName)) {
                def local_list_jars = componentNameJarMap[local_compoenentName]
                componentNameJarMap.remove(local_compoenentName)
                componentNameJarMap[local_compoenentName]=local_list_jars+","+local_jarName
            } else {
                  componentNameJarMap[local_compoenentName]=local_jarName
            }
          }

          statsWriter.println(date+separator+jarName+separator+jarCount+separator+jarNameSearchPattern+separator+jarVersions);
          componentNameJarMap.each { entry ->
              jarComponentWriter.println(date+separator+jarName+separator+entry.key+separator+entry.value)
          }
        }
    } finally {
        statsWriter.close()
        jarComponentWriter.close()
    }

    // Check if the properties file that contains connection info is present.
    File dbPropertiesFile=new File("./DbConnection.json");
    if(! dbPropertiesFile.exists()) {
      throw new FileNotFoundException("DbConnection.json file not found.");
    }

    def dbPropertiesJson = new JsonSlurper().parseText(dbPropertiesFile.text);
    
    // Load data into tables now.
    def db = Sql.newInstance(dbPropertiesJson."connectionString", dbPropertiesJson."userName", dbPropertiesJson."password", dbPropertiesJson."driver")
    try {
        def isExists = db.firstRow("SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME='thirdparty_harmonization'")
        // Create schema if it does not already exist.
        if (! isExists) {
          def sqlFileContents = new File("./create_schema.sql").text
          db.execute (sqlFileContents)
        }

        // At this point, we are guaranteed that the schema exists. Now populate.
        // Backing up information into the history tables.
        db.execute ("USE thirdparty_harmonization")
        db.execute ("INSERT INTO thirdparty_jars_stats_history SELECT * FROM thirdparty_jars_stats;")
        db.execute ("INSERT INTO thirdparty_jars_component_map_history SELECT * FROM thirdparty_jars_component_map;")

        // Now, truncate the table that holds information about the "current" run.
        db.execute ("TRUNCATE TABLE thirdparty_jars_stats;")
        db.execute ("TRUNCATE TABLE thirdparty_jars_component_map;")

        //  Load stats from the current run.
        def workingDir = new File(".").getCanonicalPath()
        db.execute("LOAD DATA LOCAL INFILE '${Sql.expand(workingDir)}/jar_stats.txt' INTO TABLE thirdparty_jars_stats FIELDS TERMINATED BY '${Sql.expand(separator)}';")
        db.execute ("LOAD DATA LOCAL INFILE '${Sql.expand(workingDir)}/jar_component_map.txt' INTO TABLE thirdparty_jars_component_map FIELDS TERMINATED BY '${Sql.expand(separator)}';")
      }finally {
          try {
            db.close();
            } catch (Exception e) {
                // Nothing to do.
            }
       }
       

        println "Finished loading database"
  }
}
